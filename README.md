# study
 2022_08_03

interface

인터페이스 정의: 인터페이스는 사용규칙을 정의한 것.
              그러므로 인터페이스에 선언하는 모든 메서드는 추상 메서드이어야 한다.

규칙1)인터페이스에 선언되는 모든 메서드는 public 이다.
-인터페이스에 정의하는 메서드는 호출 규칙이다.
-규칙은 공개되어야 한다.
규칙2) 인터페이스에 선언되는 모든 메서드는 추상 메서드로 선언한다.
-인터페이스에 선언하는 메서드는 호출 규칙을 정의한 것이다.
-규칙은 클래스가 따라야 한다.
-인터페이스에 선언되는 모든 메서드는 몸체를 구현하지 않는다.


인터페이스 레퍼런스?

=> 해당 인터페이스에 따라 작성된(사용규칙을 준수하는) 클래스의 인스턴스 주소를 저장한다.

프로그램을 코딩하다가 인터페이스를 만나게 되면

-누가 호출자이고 누가 피호출자인지 확인할것.

-본인이 맡은 개발 일이 호출자를 만드는 것인지 아니면 피호출자를 만드는 것인지 확인!



인터페이스와 추상클래스
- 인터페이스를 직접구현하면 클래스를 만드는 개발자가 인터페이스의 모든 메서드를

일일이 구현해야한다 그러므로 구현하기가 번거롭다는 단점이있다.

그래서 단점을 보완하고자 추상클래스를 활용 해서 상속 받은 클래스는 원하는 메소드만 오버라이딩한다. 인터페이스 구현을 간소화 할 수 있다.

인터페이스의 메서드 중에서 서브클래스에 공통으로 물려 줄 메서드를 미리 구현한다.



breadcrumb



2022_08_04


상속의 generaliztion 수행

concrete 클래스 구체 클래스 

GoF 디자인 패턴 - 템플릿 메서드 패턴 : 슈퍼클래스에서 틀을 잡고 서브 클래스에서 그 틀안에서 세부적으로 구체화 하는것.
*슈퍼 클래스에서 실행의 흐름을 정의하고 서브클래스에서 세부적인 작업을 구체적으로 정의하는 방식.



* Polyglot 프로그래밍
 - 여러가지 언어를 사용하여 App을 프로그래밍 하는것.

다형적 변수 와 제네릭
(polymorphic variable)

1. 다형적 변수

 object obj;
 obj = new String();
 obj = new File();
 obj = new Date();


 2. 제네릭(일반화)

 E obj;

obj = ? ; <E가 가르키는 타입이 무엇이냐에 따라 저장 할 수 있는 값이 결정된다.>
 E = 타입을 미지정할수 있다. 타입을 가르키는 변수 = 타임 파타미터라 한다.





제네릭 문법 활용


각 타입마다 클래스를 정의하다보면 유지보수가 거의 불가능하고,

오브젝트 클래스를 사용했을땐 클래스 한개만 정의해서 좋지만, 특정 파일만 저장할수 없고

매번 사용할때마다 형변환을 해야한다는 번거로움이 있다. 즉 사용이 불편하다.

제네릭 문법의 가치 
 한개의 클래스를 만들어 놓고 각 타입별로 따로 만든 클래스 인것 처럼 사용할 수 있게 해주는 문법.
   타입 정보를 전달.
objectList<E> list = new ObjectList<>();

보통 변수명은 외자 대문자로 받는 파라미터를 타입 파라미터라고 한다.

제네릭은 배열을 만드는 문법에선 제네릭 문법을 사용할수 없다. E e = new E << 이거 안됨
그래서 바깥에서 배열을 받아와서 사용하는 방법을 사용하는데 까다롭다.


 * 한개의 클래스를 정의하여 타입별로 클래스가 있는  것처럼 사용한다.
   * 즉 타입 파라미터를 이용하여 목록에서 특정 타입의 값만 다루도록 제한한다.
   * 형변환 없이 목록에 들어 있는 데이터를 꺼낸다.



2022_08_05

  
객체 지향이란
어떻게 쓰느냐 어떤 구조로 쓰느냐 
어떻게 서로 클래스와 인터페이스 인터페이스와 인터페이스와의 관계 인터페이스와 추상클래스와의 관계  
추상클래스와 이러한 관계를 어떻게 형성하느냐 오브젝트 오리엔티드 프로그래밍
설계를 얘기할줄 알아야한다.



## Iterator 패턴

stack  데이터 조회는 => pop() 
queue  데이터 조회는 => poll()
Hashset 데이터 조회는 => to Array()
                       - hashset 은 데이터를 저장할때 데이터를 가지고 특점 게산식의 결과 값을 인덱스로 사용하여 저장
                                                              l-특점 계산식의 결과값 이란 해시값 (hash value) = 정수로 된 ID 값 
                                                               -배열의 인덱스처럼 0에서 시작하는 값으로 조회 할 수 없다. 그래서 get메소드가 없다.
                    결론! 
                      데이터  저장 방식( daa staucture) 자료구조에 따라 데이터를 조회하는 방식이 다르다.
                      => 데이터 조회를 위한 코딩이 일관성이 없다.

                      해결책
                         -데이터 조회하는 일을 별도의 객체로 맡기자!
                         -단 데이터 조회 방식을 통일하기 위해 인터페이스로 조회 방식을 규격화 한다.
                       데이터 조회의 일관성 확보 = 즉 유지보수가 쉽다.


        Iterator 패턴: 데이터 조회 코드를 객체화시켜 분리
          -자료구조에 상관없이 일고나된 방법으로 데이터 조회 수행
          ->객체화 -> 다양항 조회 방식을 제공/교체

            데이터 조회를 다른 객체에게 맡긴면서 데이터 조회 방식을 통일한다.
            그렇게 되면 데이터 조회의 일관성을 확보하므로 유지보수가 쉬워진다.




  
* 객체간의 관계를 의인화 시켜서 이해를 한다면 더 큰 구조의 객체지  그램을 더 잘 이해할 수 있다.
 ( 인스턴스 한개가 한사람처럼 컨셉처럼 )

 


* 실전 : Low coupling  

*객체지향 프로그램도 어느정도는 느슨해야한다.

가능한 접점을 줄이는 방법.


1.프론트를 프랑스어로 말하면 퍼샤드 facade 패턴 (모든 학생과 얘기하다가 27:1 반장을 내새워서 반장이랑만 얘기함 1:1  ) 

      


