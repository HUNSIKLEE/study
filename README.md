# study
 2022_08_03

interface

인터페이스 정의: 인터페이스는 사용규칙을 정의한 것.
              그러므로 인터페이스에 선언하는 모든 메서드는 추상 메서드이어야 한다.

규칙1)인터페이스에 선언되는 모든 메서드는 public 이다.
-인터페이스에 정의하는 메서드는 호출 규칙이다.
-규칙은 공개되어야 한다.
규칙2) 인터페이스에 선언되는 모든 메서드는 추상 메서드로 선언한다.
-인터페이스에 선언하는 메서드는 호출 규칙을 정의한 것이다.
-규칙은 클래스가 따라야 한다.
-인터페이스에 선언되는 모든 메서드는 몸체를 구현하지 않는다.


인터페이스 레퍼런스?

=> 해당 인터페이스에 따라 작성된(사용규칙을 준수하는) 클래스의 인스턴스 주소를 저장한다.

프로그램을 코딩하다가 인터페이스를 만나게 되면

-누가 호출자이고 누가 피호출자인지 확인할것.

-본인이 맡은 개발 일이 호출자를 만드는 것인지 아니면 피호출자를 만드는 것인지 확인!



인터페이스와 추상클래스
- 인터페이스를 직접구현하면 클래스를 만드는 개발자가 인터페이스의 모든 메서드를

일일이 구현해야한다 그러므로 구현하기가 번거롭다는 단점이있다.

그래서 단점을 보완하고자 추상클래스를 활용 해서 상속 받은 클래스는 원하는 메소드만 오버라이딩한다. 인터페이스 구현을 간소화 할 수 있다.

인터페이스의 메서드 중에서 서브클래스에 공통으로 물려 줄 메서드를 미리 구현한다.



breadcrumb



2022_08_04


상속의 generaliztion 수행

concrete 클래스 구체 클래스 

GoF 디자인 패턴 - 템플릿 메서드 패턴 : 슈퍼클래스에서 틀을 잡고 서브 클래스에서 그 틀안에서 세부적으로 구체화 하는것.
*슈퍼 클래스에서 실행의 흐름을 정의하고 서브클래스에서 세부적인 작업을 구체적으로 정의하는 방식.



* Polyglot 프로그래밍
 - 여러가지 언어를 사용하여 App을 프로그래밍 하는것.

다형적 변수 와 제네릭
(polymorphic variable)

1. 다형적 변수

 object obj;
 obj = new String();
 obj = new File();
 obj = new Date();


 2. 제네릭(일반화)

 E obj;

obj = ? ; <E가 가르키는 타입이 무엇이냐에 따라 저장 할 수 있는 값이 결정된다.>
 E = 타입을 미지정할수 있다. 타입을 가르키는 변수 = 타임 파타미터라 한다.





제네릭 문법 활용


각 타입마다 클래스를 정의하다보면 유지보수가 거의 불가능하고,

오브젝트 클래스를 사용했을땐 클래스 한개만 정의해서 좋지만, 특정 파일만 저장할수 없고

매번 사용할때마다 형변환을 해야한다는 번거로움이 있다. 즉 사용이 불편하다.

제네릭 문법의 가치 
 한개의 클래스를 만들어 놓고 각 타입별로 따로 만든 클래스 인것 처럼 사용할 수 있게 해주는 문법.
   타입 정보를 전달.
objectList<E> list = new ObjectList<>();

보통 변수명은 외자 대문자로 받는 파라미터를 타입 파라미터라고 한다.

제네릭은 배열을 만드는 문법에선 제네릭 문법을 사용할수 없다. E e = new E << 이거 안됨
그래서 바깥에서 배열을 받아와서 사용하는 방법을 사용하는데 까다롭다.


 * 한개의 클래스를 정의하여 타입별로 클래스가 있는  것처럼 사용한다.
   * 즉 타입 파라미터를 이용하여 목록에서 특정 타입의 값만 다루도록 제한한다.
   * 형변환 없이 목록에 들어 있는 데이터를 꺼낸다.

