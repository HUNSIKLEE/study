


		*literal 과 메모리크기

리터럴

정수
   100 ----------------------->4byte 2진수로 변환	
   100L -------------------> 8byte 메모리에 저장된 100 2진수로 변환    0x 00 00 00 00 00 00 00 64
   100l		
자바는 언급하지 않는 이상 4byte로 저장함
자바는 리터럴은 4byte 아니면 8byte

	         IEEE-754규격	
부동소수점 12.375 ----------------> 8byte 		0x40 28 c0 00 00 00 00 00
	 12.375D
	 12.375d

	*12.375f ----------------> 4byte 	            0x41 46 00 00 00 00 00 00
	 12.375F 


표기할때는 16진수로 표기한다 0x 0(숫자한개에 4비트를 의미하기 때문에)0 00 00 0
32비트를 이진수로 표현하면 너무 길어서 보기도 읽기도 힘들어서 16진수로 표기함




	**unicode (UTF-16)
 문자 'A' ----------------------> 2byte 2진수로 변환 	0x0041
       '가'-----------------------> 			0xAC00
논리값 true  -------------------> 4byte 2진수로 변환  	0x00 00 00 01
         false  					0x00 00 00 00
* 단 논리 배열인 경우 1byte로 변환 true -> 0x01	
			        false -> 0x00

문자열  "ABC" -----------------> String 클래스에 정의된 대로 그 형식에 맞춰 변환된다.
			대충 표시한다면  0x 00 03 0041 0042 0043 (UTF-16 java8)
				         

		*메모리 크기와 값의 범위

byte	8bit   -> -128 ~ 127			4byte 정수 리터럴 : 약 -21억~21억	
short	16bit  -> -37268~ 32767 	   ->		8byte 정수 리터럴: 약 -900경~900경
int	32bit ->약 -21억 ~ +21억 			
long	64bit ->약 -922경 ~ +922경 			
		
	자바의 4바이트 아니면 8바이트에 할당된 데이터를 초과하면 컴파일에서 오류
	코드 정수 숫자에 L이 붙었다 그러면 8바이트 정수 값이다 숫자에 영어가없다? 그럼 4바이트 정수값이다
	


	부동소수점	-> 절대 완벽하게 정수로 나누어 떨어지지 않는다.		
					
float         32bit 	---------------->	유효자릿수 7자리까지 거의 정상적으로 저장한다. 	
single 				(소수점을 빼고 남은 수의 개수)	
precision
(단정도)
					
double      64bit	--------------->	유효자릿수 15자리까지 거의 정상적으로 저장한다. 	
precision				(소수점을 빼고 남은 수의 개수)		
(배정도)	
	

부동소수점은 컴파일하면 에러가 안뜨고 이상한값이 되버려서 많이 실수하기때문에 주의 해야함.
부동소수점 기본은 double 8byte 인 이유는 4byte로는 실생활에서 사용하기가 많이 부족하다. 소수점 포함 7자리는
예를들어 달러로 표현하면 표현할수있는게 백만달라밖에 못해서 실생활에서는 천만달라도 쓰고 뭐 부동소수점 십만달러.14센트
이런식으로 쓰면 십만달러도 표현 못하기때문에 부동소수점 기본이 8byte로 15자리까지 사용된다.		

	
	
	* 문자와 코드
	         unicode		utf-8		ISO-8859-1	EUC-KR	
	'A'  -> 0x0041		0x41		 0x41		  없음	
	'가' -> 0xAC00		0xEAB080  	 없음		 0xB0A1
	'?'  ->  0x003F		0x3F		0x3F
	'=' ->  0x003D		0x3D		0x3D
	'%' -> 0x0025		0x25		0x25
	'&' -> 0x0026		0x26		0x26	 
	' '  -> 0x0020		0x20		0x20
	CR ->0x000D		0x0D		0x0D
	(carray Return)
	LF -> 0x000A		0x0A		0x0A
	(Line Feed)
	
				
			*줄바꿈 코드
		      
windows 2 byte ->  CR(carray Return) 	 LF(Line Feed)  ->	0D 0A
		   1byte 1byte	

unix  1byte ->	LF( Line Feed) 	     ->	 0A
		1byte


			* 문자 리터럴

 	 'A'  ,
	 '가'

     직접 문자를 적는 대신에 그 문자에 부여된 코드 값을 지정할 수 있다.
     문자에 대해 부여된 값을 '문자 코드(character code)'라 부른다.
     코드 값은 사용하는 문자 집합에 따라 다르다.
     자바는 '유니코드(UTF-16BE; UCS2)' 라는 문자집합을 사용한다.
     \ u 뒤에 문자에 부여된 코드 값을 16진수로 적는다.
     u는 소문자로 적어야 한다.



    System.out.println('\u0041');  // A
    System.out.println('\uac00');  // 가
    System.out.println('\uAC00');  // 가 (16진수는 대소문자를 구분하지 않는다)



               	         unicode			arial	굴림체	궁서체
 	 'A'  ----------> 0x0041        -------------->	 A	A	  A
	 '가' ----------> 0xAC00	 --------------->	없음	가	  가	


Ex03 예제 410번 실행하면 
A
가
A
가
가
A
R
?             <-
人
?	  <- 뜨는 이유 폰트파일에 해당코드의 문자가 그림이 없으면 출력할 수 없다.
π
Σ

cmd는 문자를 출력할때 저장된 문자 포트를 가져와서 출력하는데 문자 깨지는이유 윈도우는 ms949 에
저장된 문자 포트에 그림이 없기때문에 오류가 난다. 리눅스는 utf8 기본 설정이라 다들어있다.
그래서 윈도우에서는 ms949라 그림파일이 없기때문에 유니코드를 직접 입력해야된다.

    System.out.println('\u4eba'); // 사람을 뜻하는 '인(人)'이라는 한자의 문자 코드
    System.out.println('\u00a9'); // copyright를 뜻하는 '©' 문자 코드 ?표로 표시됨
    System.out.println('\u03c0'); // 수학의 파이 기호 'π'
    System.out.println('\u03a3'); // 수학의 시그마 기호 'Σ'

이런 기호식 넣을때는 유니코드 사용해야함.

    


			*Escape 문자 (특수 코드)
\u유니코드		  
\n - Line Feed(LF), 0x0a		-> 줄바꿈 코드 삼입	문자나 문자열 속에 줄바꿈 코드를 삽입할때 사용
\r - Carrage Return(CR), 0x0d	-> CR코드삼입		주로 \n(LF) 코드만 단독적으로 사용한다.
\f - Form Feed, 0x0c		-> Form Feed(다음 용지) 잘안씀			
\t - Tab, 0x09			-> Tab 				
\b - Backspace, 0x08		-> abc\bxyz => abxzy (c가 사라진 이유는 백스페이스 때문에 c로 이동해서 덮어씌어짐)			
\' - Single Quote, 0x27		-> 문자로 표현하고 싶을때 씀				
\" - Double Quote, 0x22		-> 문자로 표현하고 싶을때 씀				
\\ - Backslash, 0x5c		-> 문자로 표현하고 싶을때 씀					
		
자바에선 \ 만 쓸수없다 에스케이프 문자 때문에 \를 표시하기 위해선 \\ 두번 써야 한다.







						

 
				*폰트는

픽셀 단위로 그리는 방식 을 Raster 폰트
Raster 방식
 장점  
  -출력 속도는 빠르다.
.
 단점
  -픽셀 단위위로 그리기때문에 그림크기를 확대하면 계단현상이 발생한다.
  -파일 크기가 크다 
 cpu느릴때 많이 사용했던 방법


  점과 점을연결하고 특정 수학식에 따라 그리는 방식을 Vector 폰트 or True Type 폰트라 부른다
Vector 방식
 점과 점을연결하고 특정 수학식에 따라 그리는 방식
 장점
  -그림크기 확대하도 미려하게 출력가능.
  - 파일 크기가 작다
★단! 그림이 복잡하면 Vector 명령이 많아지기때문에 파일크기가 커진다. ex) 캐드
 단점
  -계산이필요해서 출력속도가 느리다.


cpu가빨라져서 사용


현대는 백터폰트를 많이 사용한다.



  		*비트맵과 Vector 방식



비트맵		.g			Vector 이미지	
							
							
Raster 방식				Vector 방식		
그림크기 조정 계단현상 발생			-그림크기 조정	그대로 유지됨	














